(ns strictly-specking.core
  (:require
   [strictly-specking.parse-spec :as parse]
   [strictly-specking.strict-keys :as strict-impl]
   [strictly-specking.ansi-util :as cl :refer [color]]
   [strictly-specking.annotated-pprint :as annot]
   [strictly-specking.edn-string-nav :as edn-string-nav]
   [strictly-specking.context-print :as cp]
   [strictly-specking.fix-paths :refer [fix-error-path]]
   [strictly-specking.path-matching :as path-match]
   [strictly-specking.error-printing :refer [error-message
                                             inline-message
                                             pprint-inline-message] :as ep]
   [clansi.core :refer [with-ansi]]
   [clojure.pprint :as pp]
   [clojure.string :as string]
   [clojure.set :as set]
   [clojure.spec :as s]))

#_(remove-ns 'strictly-specking.core)

;; *** TODO move to predicates load file

(defn non-blank-string? [x] (and (string? x) (not (string/blank? x))))


;; * Helper specs
;; 

;; ** Strict-keys Spec

(defmacro strict-keys
  "This is a spec that has the same signature as the clojure.spec/keys spec.
  The main difference is that it fails on keys that are not the 
  [:req :opt :req-un :opt-un] specifications.

  This spec will provide an explanation for each unknown key."
  [& args]
  ;; check the args with s/keys
  ;; `(s/keys ~@args)
  (let [form (macroexpand `(s/keys ~@args))]
    `(strictly-specking.strict-keys/strict-mapkeys-impl
      (strictly-specking.parse-spec/parse-keys-args ~@args) ~form)))


;; ** Attach Reason Spec

;; attach-reason is a spec that attaches a :reason to a failing specs
;; explain-data this :reason is printed out as part of the message
;; generated by clojure.spec/explain

(defn ammend-explain-impl [parent-spec {:keys [reason] :as additional-info}]
  {:pre [(or (nil? reason) (string? reason))]}
  (reify
    clojure.lang.IFn
    (invoke [this x] (parent-spec x))
    clojure.spec/Spec
    (conform* [_ x] (s/conform* parent-spec x))
    (unform* [_ x] (s/unform* parent-spec x))
    (explain* [_ path via in x]
      (when-let [err (first (s/explain* parent-spec path via in x))]
        [(cond-> err
           (::attach-reason additional-info)
           (update-in [:reason] #(if %
                                   (str (::attach-reason additional-info) "\n - " %)
                                   (::attach-reason additional-info)))
           true   (merge additional-info))]))
    ;; These can be improved
    (gen* [_ a b c]
      (s/gen* parent-spec a b c))
    (with-gen* [_ gfn]
      (s/with-gen* parent-spec gfn))
    (describe* [_] (s/describe* parent-spec))))

(defmacro attach-reason [reason spec & additional-info]
  `(ammend-explain-impl (s/spec ~spec)
                        ~(into {::attach-reason reason}
                               (apply hash-map additional-info))))

#_(s/explain-data (attach-reason "asdf" (fn [x] false)
                               :focus-key :asdf)
                {})

;; ** Attach Warning Spec

;; There are situations that we just want to warn about. Here is a spec
;; that will print out a warning and will always pass.

(defn attach-warning-impl [message-or-fn parent-spec]
  {:pre [(or (fn? message-or-fn) (string? message-or-fn))]}
  (reify
    clojure.lang.IFn
    (invoke [this x] (parent-spec x))
    clojure.spec/Spec
    (conform* [_ x]
      (if (s/valid? parent-spec x)
        (s/conform* parent-spec x)
        (do
          (println "CLJS Compiler Options Warning: " (if (string? message-or-fn)
                                                       message-or-fn
                                                       (message-or-fn x)))
          x)))
    (unform* [_ x] x)
    (explain* [_ path via in x] nil)
    ;; These can be improved
    (gen* [_ a b c]
      (s/gen* parent-spec a b c))
    (with-gen* [_ gfn] 
      (s/with-gen* parent-spec gfn))
    (describe* [_] (cons 'attach-warning (s/describe* parent-spec)))))

(defmacro attach-warning [reason spec]
  `(attach-warning-impl ~reason (s/spec ~spec)))

;;

;; * docs on keys
;;

;; our own private registry for data on keys

(defonce ^:private registry-ref (atom {}))

(defn def-key-doc [k d]
  (swap! registry-ref assoc-in [k ::doc] d))

(defn key-doc [k]
  (get-in @registry-ref [k ::doc]))


;; ** A def-key construct

;; Creating a def-key contruct to allow for simultaneous defining of
;; specs and docs, this will also check for duplicate keys

(defonce ^:private registry-ref (atom {}))

(defn key-doc
  "Given a spec key returns a String of documentation if it has been provided"
  [k]
  (get-in @registry-ref [k ::doc]))

(defn add-key-doc [k doc]
  {:pre [(keyword? k) (string? doc)]}
  (swap! registry-ref assoc-in [k ::doc] doc))

(defn key-docs-for-explain-data
  "Given explain data from a failed spec provides a Map of key -> doc"
  [explain-data]
  (->> explain-data
       ::s/problems
       vals
       (keep (comp (juxt identity key-doc) last :via))
       (filter second)
       (into {})))

;; ** Checking for duplicate keys

;; As a spec gets larger its very easy to duplicate a key and break
;; everything. It's nice to have a safe guard in place.

;; can use this to test for duplicate definitions This works fine with
;; a reloading workflow as long as you reload the whole file.

(def ^:private duplicate-keys (atom {}))

(defn duplicate-key-check* [k]
  (when (get @duplicate-keys k)
    (throw (ex-info "Error duplicate key spec" {:k k})))
  (swap! duplicate-keys assoc k true)
  k)

;; a development helper
(defn reset-duplicate-keys
  "Empties the duplicate keys atom. Only intended for interactive development."
  [] (reset! duplicate-keys {}))

;; parse out args
(def def-key-arg-spec (s/cat :k (s/and keyword? namespace)
                             :spec ::s/any
                             :doc (s/? non-blank-string?)))

(defmacro def-key
  "Defines a spec via clojure.spec/def, checks for duplicates and adds optional documentation.

Usage:
(def-key ::my-keyword-key string? \"Optional documentation\")"
  [& args]
  (let [{:keys [k spec doc] :as res} (s/conform def-key-arg-spec args)]
    (if-not (and k spec)
      (throw (ex-info
              (with-out-str (s/explain def-key-arg-spec args))
              (or (s/explain-data def-key-arg-spec args) {})))
      `(do
         (duplicate-key-check* ~k)
         (s/def ~k ~spec)
         ~(when doc
            `(add-key-doc ~k ~doc))))))

;; *** keys to document
;;
;; this should dispatch and display in file context if there is file
;; information on the error

;; **** different errors need different strategies
;; we need to turn un-namespaced keywords in to ns-keywords
;; for documentation lookup

(defn search-for-key-in-via [via k]
  (some #(when (or (= (name %) (name k))
                   (= k %))
           %) (reverse via)))

;; TODO this could miss some keys because we are using in
;; better to use :in-path
(defn get-key-to-document [e]
  (let [{:keys [via in]} e]
    (->> (reverse in)
         (filter keyword?)
         (some #(search-for-key-in-via via %)))))

#_(get-key-to-document '{:path [:source-paths],
                         :pred string?,
                         :val 1,
                         :via [:fig-opt/build-config :build-config/source-paths :build-config/source-paths],
                         :in [:source-paths 0],
                         :strictly-specking.core/error-type :strictly-specking.core/bad-value,
                         :strictly-specking.core/root-data {},
                         :strictly-specking.core/file-source "asdf"})

(defn look-up-ns-keywords-in-spec
  "Fetches the child ns-keys of a spec given the un-namespaced keys."
  [typ kys]
  (when-let [desc (try (s/describe typ) (catch Throwable e nil))]
    (when-let [path-elems (not-empty (parse/possible-child-keys typ))]
      (->> path-elems
           (filter (fn [{:keys [ky ky-spec]}] ((set kys) ky)))
           (map :ky-spec)))))

(defmulti keys-to-document ::error-type)

(comment
  (keys-to-document '{:path [],
                      :pred (and (contains? % :id) (contains? % :source-paths)),
                      :val {:compiler 1, :asdfasdf [1 2]},
                      :via [:fig-opt/builds :fig-opt/builds :fig-opt/build-config :fig-opt/build-config],
                      :in [0],
                      :strictly-specking.core/missing-keys [:id :source-paths],
                      :strictly-specking.core/error-type :strictly-specking.core/missing-required-keys,
                      :strictly-specking.core/root-data [{:compiler 1, :asdfasdf [1 2]}],
                      :strictly-specking.core/file-source "tester.edn"})

  (keys-to-document '{:strictly-specking.core/root-data {},
                      :path [:misspelled-key :source-path],
                      :strictly-specking.core/error-type :strictly-specking.core/misspelled-key,
                      :strictly-specking.core/misspelled-key :source-path,
                      :pred #{:asdfasdf :source-paths :assert :id},
                      :via [:fig-opt/build-config],
                      :val {:id 1, :source-path [1 2]},
                      :strictly-specking.core/file-source "asdf",
                      :strictly-specking.core/correct-key :source-paths,
                      :in []})

  (keys-to-document '{:path (:strictly-specking.core/combined-path [:id :string] [:id :keyword]),
                      :pred (or string? keyword?),
                      :val 1,
                      :via [:fig-opt/build-config :build-config/id],
                      :in [:id],
                      :strictly-specking.core/error-type :strictly-specking.core/bad-value-comb-pred,
                      :strictly-specking.core/root-data {},
                      :strictly-specking.core/file-source "asdf"})
  
  (keys-to-document '{:path [:source-paths],
                      :pred string?,
                      :val 1,
                      :via [:fig-opt/build-config :build-config/source-paths :build-config/source-paths],
                      :in [:source-paths 0],
                      :strictly-specking.core/error-type :strictly-specking.core/bad-value,
                      :strictly-specking.core/root-data {},
                      :strictly-specking.core/file-source "asdf"})

 (keys-to-document '{:path [:cljsbuild],
                     :pred (contains? % :builds),
                     :val {}
                     ,
                     :via
                     [:strictly-specking.test-schema/lein-project-with-cljsbuild
                      :cljsbuild.lein-project.require-builds/cljsbuild],
                     :in [:cljsbuild],
                     :strictly-specking.core/missing-keys [:builds],
                     :strictly-specking.core/error-type :strictly-specking.core/missing-required-keys
})
  
  )

(defn fetch-docs [kys]
  (->>  kys
       (keep (fn [k] (when-let [d (key-doc k)]
                       [k d])))
       (into {})))




;; * moving from errors to messages

;; ** filtering errors
;;
;; *** upgrading unknown key errors to misplaced or misplaced misspelled key errors
;; *** could remove the possible missing required
;; *** key errors caused by misspelling could remove the local versions of
;;     these "duplicate" errors in strict-keys perhaps add a reconizable type
;; *** TODO need to add the original structure that the errors are on

#_ (def terrors (s/explain-data :fig-opt/builds [{:compiler 1
                                                  :id 1
                                                  :source-path 2
                                                  }]))

;; *** detect missing-keys 

;; the differnt errors get their own predicate which ammend the error on
;; passing

;; this predicate becomes part of a flow of errors that can raise the value of
;; and improve the previous errors

;; how do we register these predicates into this flow
;; perhaps middleware pattern? again??

;; we want to be able to increase and decrease the degree of error detection
;; so we can register and error and its prerequisite


;; by using derive and providing ordering by eliminating siblings
;; have are creating a very extensible system where other libs
;; can introduce errors into the heirarchy

(def sibling-elimination (atom {}))

(defn eliminate-siblings
  "This is a mechanism to state that my sibling types must not apply
before you try me."
  [typ & to-eliminate]
  (assert (keyword? typ))
  (assert (namespace typ))
  (assert (every? #(and (keyword? %)
                        (namespace %)) to-eliminate))
  (swap! sibling-elimination assoc typ (set to-eliminate)))

(defn order-siblings-by-elimination
  "This is a graph sorting of siblings based on what the require to
  have happened first"
  [siblings]
  (if (= 1 (count siblings))
    siblings
    (first
     (for [sib siblings
           :let [rest-sibs (remove #(= sib %) siblings)
                 eliminations (set (apply concat
                                          (keep @sibling-elimination rest-sibs)))]
           :when (not (eliminations sib))
           :let [ordering (order-siblings-by-elimination rest-sibs)]
           :when ordering]
       (cons sib ordering)))))

(defn derived-children [typ]
  (->> @#'clojure.core/global-hierarchy
       :parents
       (filter (fn [[k v]] (v typ)))
       (map first)))

(defn children-in-order [typ]
  (let [desc (derived-children typ)]
    (reverse (order-siblings-by-elimination desc))))

#_(children-in-order ::unknown-key)


#_(order-siblings-by-elimination [] #_(reverse
                                     (list :strictly-specking.core/triangle
                                           :strictly-specking.core/rect
                                           :strictly-specking.core/circle
                                           :strictly-specking.core/elipse
                                           :strictly-specking.core/fiive)))
(def root-error-type ::bad-value)

(defn total-order
  "this is used to give precedence to the display of errors"
  ([] (cons root-error-type (total-order root-error-type)))
  ([root-type]
   (let [desc (children-in-order root-type)]
     (concat desc (mapcat total-order desc)))))


(defmulti upgrade-to-error-type?
  "Takes an spec based problem and an error-type and returns

An upgraded error if the error is a match
nil if no match 
:try-descedants if this error is in a chain of errors 
to try in order
"
  (fn [error-type err] error-type))

;; now we can simply go through the tree of errors types
;; this can be upgraded to skip errors in an skip-errors set

;; TODO fill this in
(def ^:dynamic *skip-errors* #{})

(defn upgrade-error* [error-type e]
  (when-let [upg-err (upgrade-to-error-type? error-type e)]
    (let [descend (children-in-order error-type)]
      (or (some #(upgrade-error* % upg-err) descend)
          upg-err))))

;; we always upgrade errors from the root

(def upgrade-error (partial upgrade-error* root-error-type))

;; error path returns the error path type for the error
;; error-path-type
;; { :in-path [] ;; a vector path that works with get-in on the root datastructure 
;;   :error-focus :value ;; or :key
;;   ;; missing key isn't necessary we can tell if the collection doesn't have it
;;   :missing-key true } 

(defmulti error-path ::error-type)

;; error-parent-path always butlast of :path
(defn error-path-parent [error-path]
  (assert (and (map? error-path) (:in-path error-path)))
  (or (butlast (:in-path error-path)) []))

(defn error-key [error-pth]
  (-> error-pth :in-path last))

#_(upgrade-error {})

#_(order-siblings-by-elimination #{::rect ::circle ::elipse ::triangle ::fiive})

;; *** bad-value error

(defmethod upgrade-to-error-type? ::bad-value [_ {:keys [error-type] :as err}]
  ;; this may be the one case where we just pass something with an error type
  ;; through but let's keep the semantics well defined now
  (when (nil? (::error-type err))
    (assoc err ::error-type ::bad-value)))

;; need to watch and see how often this is called
;; as its a little bit of an intense calculation
(defn default-error-path [err]
  {:in-path (fix-error-path err)
   :error-focus :value
   :missing-key false})

(defmethod error-path ::bad-value [err]
  (default-error-path err))

#_(error-path (upgrade-error (test-e (s/map-of keyword? integer?) {:Asdf :asdf})))

;; printing a bad value message

(defn parent-collection [e]
  (when-let [par-path (error-path-parent (::error-path e))]
    (get-in (::root-data e) par-path)))

(defn bad-value-message [{:keys [path pred val reason via in] :as e}]
  (let [ky  (error-key (::error-path e))
        ;; I don't think its possible for this to be nil
        pth (error-path-parent (::error-path e))
        parent-coll  (parent-collection e)]
    (cond
      (map? parent-coll)
      (str "The key " (color (pr-str ky) :focus-key)
           " at "     (color (pr-str pth) :focus-path)
           " has a non-conforming value: " (ep/format-bad-value val)
           "\n" (ep/format-predicate-str e))
      ;; handle sequential collections differently
      (coll? parent-coll)
      (str "The " (ep/type-str parent-coll)
           " at " (color (pr-str pth) :focus-path)
           " contains a non-conforming value: " (ep/format-bad-value val)
           "\n" (ep/format-predicate-str e))
      :else
      (str "The key " (color (pr-str ky) :focus-key)
           " has a non-conforming value: " (ep/format-bad-value val)
           "\n" (ep/format-predicate-str e)))))

(defmethod error-message ::bad-value [e] (bad-value-message e))
(defmethod error-message ::bad-value-comb-pred [e] (bad-value-message e))

(defmethod inline-message ::bad-value [e]
  (str "The value at key " (error-key (::error-path e)) " has a non-conforming value"))
(defmethod inline-message ::bad-value-comb-pred [e]
  (str "The value at key " (error-key (::error-path e)) " has a non-conforming value"))

(defmethod pprint-inline-message :default [e]
  (let [err-path (::error-path e)]
    ;; TODO handle missing key
    (ep/pprint-in-context e (error-path-parent err-path)
                          {(error-key err-path) (inline-message e)}
                          ;; can change the colors based on focus
                          (let [focus (:error-focus err-path)]
                            (if (= :key focus)
                              {:key-colors   [:error-key]
                               :value-colors [:none]}
                              {:key-colors   [:highlight]
                               :value-colors [:bad-value]})))))

(defmethod keys-to-document :default [e]
  (or (::document-keys e)
      (when-let [k (get-key-to-document e)]
        [k])))


(comment
  (let [errs (s/explain-data :strictly-specking.test-schema/build-config
                             {:id 5})]
    (dev-print errs
               {:id 5}
               nil)
    (prepare-errors errs
                    {:id 5}
                    nil))

  (let [errs (s/explain-data (s/map-of keyword? (s/or :key keyword? :str string?))
                             {:id 5})]
    (dev-print errs
               {:id 5}
               nil)
    (prepare-errors errs
                    {:id 5}
                    nil))

  )




;; *** attach reason error
(derive ::attach-reason ::bad-value)

;; this is basically a no-op
;; we could simply the ::error-type in the macro

(defmethod upgrade-to-error-type? ::attach-reason [_ err]
  (when (::attach-reason err)
    (assoc err ::error-type ::attach-reason)))

#_(upgrade-error (test-e (attach-reason "asdf" (fn [x] false)
                               :focus-key :asdf)
                         {}))

(defmethod error-path ::attach-reason [{:keys [val focus-key] :as err}]
  (if focus-key
    {:in-path (concat (fix-error-path err)
                      (list focus-key))
     :error-focus :key
     :missing-key (not (get val focus-key))}
    (default-error-path err)))

#_ (error-path
    (upgrade-error (test-e (attach-reason "asdf" (fn [x] false)
                                          :focus-key :asdf)
                           {:asdf 1})))

#_ (error-path
    (upgrade-error (test-e (attach-reason "asdf" (fn [x] false)
                                          :focus-key :asdf)
                           {})))

(defmethod error-message ::attach-reason [e]
  (str "Error at "
       (color (pr-str (vec (:in-path (::error-path e)))) :focus-path) "\n"
       (:reason e "")))

(defmethod inline-message ::attach-reason [e]
  (:reason e " error here"))

(defmethod keys-to-document ::attach-reason [e]
  (when-let [typ (last (:via e))]
    (look-up-ns-keywords-in-spec typ (when-let [x (:focus-key e)]
                                       [x]))))


(comment
  (let [data {:output-to "main.js"
              :source-map "asdf"
              :optimizations :none}
        errs (s/explain-data :strictly-specking.test-schema/compiler
                             data)]
    (dev-print errs
               data
               nil)
    (prepare-errors errs
                    data
                    nil))
  )



;; *** wrong-size-collection

(derive ::wrong-size-collection ::bad-value)

;; TODO this needs a test to make sure that it doesn't change
;; from under us
(defn wrong-size-pred? [pred]
  (when (and (sequential? pred)
             (sequential? (nth pred 2 nil)))
    (let [[cc<=' min-v [cccount' _] max-v] pred]
      (when (and (= cc<=' 'clojure.core/<=)
                 (= cccount' 'clojure.core/count))
        {::min-count min-v
         ::max-count max-v}))))

#_ (wrong-size-pred? '(clojure.core/<= 2 (clojure.core/count %) Integer/MAX_VALUE))
;; doesn't throw error
#_ (wrong-size-pred? '(clojure.core/<= 2 d (clojure.core/count %) Integer/MAX_VALUE))

(defmethod upgrade-to-error-type? ::wrong-size-collection [_ {:keys [pred] :as err}]
  (when-let [merge-data (wrong-size-pred? pred)]
    (-> err
        (merge merge-data)
        (assoc ::error-type ::wrong-size-collection))))

#_ (upgrade-error (test-e (s/every integer? :min-count 2) []))
#_ (error-path    (upgrade-error (test-e (s/every integer? :min-count 2) [])))

(defn pluralize [w i]
  (if (= 1 i) w (str w "s")))

(defn it-should-have-at-least [i w]
  (str "It should have at least " (color i :good) " "
       (pluralize w i)))

(defmethod error-message ::wrong-size-collection [{:keys [path pred val reason via in] :as e}]
  ;; the base case here is an
  (str "The collection at key "
       (error-key (::error-path e))
       " is too small it only contains " (color (count (:val e)) :bad-value) " "
       (pluralize "value" (count (:val e))) "\n"
       (it-should-have-at-least (::min-count e) "value") "\n"))

(defmethod inline-message ::wrong-size-collection [e]
  (str "The collection is too small"))

(comment
  (let [data {:data-key []}
        errs (s/explain-data (s/map-of keyword? (s/every integer? :min-count 2))
                             data)]
    (dev-print errs
               data
               nil)
    (prepare-errors errs
                    data
                    nil))
  )

;; *** wrong-count-collection

(derive ::wrong-count-collection ::bad-value)

(defn wrong-count-pred? [pred]
  (when (and (sequential? pred)
             (sequential? (nth pred 2 nil)))
    (let [[=' target-count [count' _]] pred]
      (when (and (integer? target-count)
                 (= 'clojure.core/count count')
                 (= 'clojure.core/=     ='))
        {::target-count target-count}))))

#_(wrong-count-pred? '(clojure.core/= 2 (clojure.core/count %)))
;; doesn't throw error
#_(wrong-count-pred? '(clojure.core/= 2 s (clojure.core/count %)))

(defmethod upgrade-to-error-type? ::wrong-count-collection [_ {:keys [pred] :as err}]
  (when-let [merge-data (wrong-count-pred? pred)]
    (-> err
        (merge merge-data)
        (assoc ::error-type ::wrong-count-collection))))

#_ (upgrade-error (test-e (s/every integer? :count 1) []))
#_ (error-path    (upgrade-error (test-e (s/every integer? :count 1) [])))

(defmethod error-message ::wrong-count-collection [{:keys [path pred val reason via in] :as e}]
  ;; the base case here is an
  (str "The collection at key "
       (error-key (::error-path e))
       " has the wrong size: " (color (count (:val e)) :bad-value) "\n"
       "The count should be = to " (color (::target-count e) :good)))

(defmethod inline-message ::wrong-count-collection [e]
  (str "The collection should have exactly " (::target-count e) " " (pluralize "value" (::target-count e))))

(comment
  (let [data {:data-key []}
        errs (s/explain-data (s/map-of keyword? (s/every integer? :count 2))
                             data)]
    (dev-print errs
               data
               nil)
    (prepare-errors errs
                    data
                    nil))
  )


;; *** should-not-be-empty

(derive ::should-not-be-empty ::wrong-size-collection)

(defmethod upgrade-to-error-type? ::should-not-be-empty [_ err]
  (when (and
         (= (::min-count err) 1)
         (= (::max-count err) 'Integer/MAX_VALUE))
    (assoc err ::error-type ::should-not-be-empty)))

#_ (upgrade-error (test-e (s/every integer? :min-count 1) []))
#_ (error-path    (upgrade-error (test-e (s/every integer? :min-count 1) [])))

(defmethod error-message ::should-not-be-empty [{:keys [path pred val reason via in] :as e}]
  (str "The value " (color (pr-str val) :bad-value)
       " at key " (color (error-key (::error-path e)) :focus-key)
       " should not be empty.\n"
       (it-should-have-at-least 1 "value")))

(defmethod inline-message ::should-not-be-empty [e]
  (str "The value at key " (error-key (::error-path e)) " should not be empty"))

(comment
  (let [data {:data-key []}
        errs (s/explain-data (s/map-of keyword? (s/every integer? :min-count 1))
                             data)]
    (dev-print errs
               data
               nil)
    (prepare-errors errs
                    data
                    nil))
  )


;; *** missing required keys
;; 

(derive ::missing-required-keys ::bad-value)

(defn missing-keys? [pred]
  (when ((every-pred sequential?
                     #(= (first %) 'contains?)
                     #(keyword? (last %))) pred)
    {::missing-keys [(last pred)]}))

(defmethod upgrade-to-error-type? ::missing-required-keys [_ {:keys [pred] :as err}]
  (when-let [merge-data (missing-keys? pred)]
    (-> err
        (merge merge-data)
        (assoc ::error-type ::missing-required-keys))))

(defmethod error-path ::missing-required-keys [err]
  {:in-path (concat (fix-error-path err)
                    (take 1 (::missing-keys err))) 
   :error-focus :key
   :missing-key true})



#_(upgrade-error (test-e (s/keys :req-un [::fdas]) {:asdf 3}))

#_(error-path (upgrade-error (test-e (s/keys :req-un [::fdas]) {:asdf 3})))

#_(missing-keys '{:path [], :pred (contains? % :id), :val {}, :via [:fig-opt/build-config], :in []})

(defmethod error-message ::missing-required-keys [{:keys [path pred val reason via in] :as e}]
  (when-let [kys (not-empty (::missing-keys e))]
    (str "Missing required " (pluralize "key" (count kys)) " "
         (ep/format-seq-with-and kys) " at path "
         (color (pr-str (error-path-parent (::error-path e))) :focus-path))))

(defmethod pprint-inline-message ::missing-required-keys [e]
  (or
   (and (::file-source e) (ep/pprint-missing-keys-in-file-context e))
   (ep/pprint-sparse-path (::root-data e)
                          (error-path-parent (::error-path e))
                          (into {}
                                (map (fn [k]
                                       [k (str "The required key " (pr-str k) " is missing")]))
                                (::missing-keys e)))))

(defmethod keys-to-document ::missing-required-keys [e]
  (when-let [missing (not-empty (::missing-keys e))]
    (let [typ  (last (:via e))]
      (look-up-ns-keywords-in-spec typ missing))))

(comment
  (let [data {}
        errs (s/explain-data (strict-keys :req-un [::asdf])
                             data)]
    (dev-print errs
               data
               nil)
    (prepare-errors errs
                    data
                    nil))


  )


;; *** bad key
;; this is a case where we have a s/map-of or s/every-kv

(derive ::bad-key ::bad-value)

(eliminate-siblings ::bad-key ::unknown-key) ;; if this isn't an unknown key

(defmethod upgrade-to-error-type? ::bad-key [_ {:keys [in val] :as err}]
  (when (= [0 val] (take 2 (reverse in)))
    (assoc err ::error-type ::bad-key)))

(defmethod error-path ::bad-key [err]
  (-> (default-error-path err)
      (assoc :error-focus :key)))

#_(upgrade-error (test-e (s/map-of keyword? integer?) {"asdf" 3}))

#_(error-path
   (upgrade-error (test-e (s/map-of keyword? integer?) {"asdf" 3})))

(defn bad-key-message [{:keys [path pred val reason via in] :as e}]
  (str "The key " (color (pr-str (error-key (::error-path e)))
                         :focus-key)
       " at " (color (pr-str (error-path-parent (::error-path e))) :focus-path)
       " does not conform. "
       "\n" (ep/format-predicate-str e)))

(defmethod error-message ::bad-key [e]           (bad-key-message e))
(defmethod error-message ::bad-key-comb-pred [e] (bad-key-message e))

(defn bad-key-inline-message [e]
  (str "The key " (pr-str (error-key (::error-path e)))
       " does not conform."))

(defmethod inline-message ::bad-key [e] (bad-key-inline-message e))
(defmethod inline-message ::bad-key-comb-pred [e] (bad-key-inline-message e))

(comment
  (let [data {"" 1
              3 3}                               ;; below is for combined key errors
        errs (s/explain-data (s/map-of integer? #_(s/or :key keyword? :int integer?)
                                       integer?)
                             data)]
    (dev-print errs
               data
               nil)
    (prepare-errors errs
                    data
                    nil))
  )



;; NEXT level is ::unknown-key problems



;; *** unknown key

(derive ::unknown-key ::bad-value)

;; this only works with the strict-keys implementation
;; TODO think about getting rid of the strict keys complexity
;; and just pulling the data out of a pred
(defmethod upgrade-to-error-type? ::unknown-key [_ err]
  (when (::unknown-key err)
    (assoc err ::error-type ::unknown-key)))

(defmethod error-path ::unknown-key [err]
  {:in-path (concat (fix-error-path err)
                    (list (::unknown-key err)))
   :error-focus :key})

#_(upgrade-error (test-e (strict-keys :opt-un [::fdas]) {:asdf 3}))
#_ (error-path (upgrade-error (test-e (strict-keys :opt-un [::fdas]) {:asdf 3})))

(defmethod error-message ::unknown-key [{:keys [path pred val reason via in] :as e}]
  (str "Found unrecognized key " (color (pr-str (::unknown-key e)) :error-key)
       " at path " (color (pr-str (error-path-parent (::error-path e))) :focus-path) "\n"
       ;; doesn't work when there is only one key
       (if (= 1 (count pred))
         (str "The only allowed key is: " (pr-str (first pred)) )
         (str "Must be one of: " (ep/format-seq-with-or pred)))))

(defmethod inline-message ::unknown-key [e]
  (str "The key " (::unknown-key e) " is unrecognized"))

(defmethod keys-to-document ::unknown-key [e] nil)

(comment
  (let [data {:abcd 1}                               
        errs (s/explain-data (strict-keys :opt-un [::fargo])
                             data)]
    (dev-print errs
               data
               nil)
    (prepare-errors errs
                    data
                    nil))
  )


;; *** misspelled-key
;; upon reflection misspelling and wrong keys should have multiple options for correction
;; we probably should move ::correct-key to ::correct-keys

(derive ::misspelled-key ::unknown-key)

(defmethod upgrade-to-error-type? ::misspelled-key [_ err]
  (when-let [suggest
             (and
              (::keys->specs err)
              ((some-fn keyword? string? symbol?) (::unknown-key err))
              (strict-impl/spelling-suggestion
               (parse/keys-specs->keys-args (::keys->specs err))
               (:val err)
               (::unknown-key err)))]
    (assoc err
           ::error-type ::misspelled-key
           ::misspelled-key (::unknown-key err)
           ::correct-key suggest)))

(defmethod error-message ::misspelled-key [{:keys [path pred val reason via in] :as e}]
  (str "It's likely that the key " (color (pr-str (::misspelled-key e)) :error-key)
       " is misspelled. It should probably be "
       (color (pr-str (::correct-key e)) :correct-key)))

(defn correct-key-message [e]
  (str "The key " (pr-str (-> e ::error-path error-key))
       " should probably be " (pr-str (::correct-key e))))

(defmethod inline-message ::misspelled-key [e]
  (correct-key-message e))

(defn correct-keys-to-document [e]
  (when-let [spec-key (get (::keys->specs e)
                           (::correct-key e))]
    [spec-key]))

(defmethod keys-to-document ::misspelled-key [e]
  (correct-keys-to-document e))

(comment
  (let [data {:farg 1}                               
        errs (s/explain-data (strict-keys :opt-un [::fargo])
                             data)]
    (dev-print errs
               data
               nil)
    (prepare-errors errs
                    data
                    nil)
    (keys-to-document (first (prepare-errors errs
                                             data
                                             nil)))
    )
  )

;; *** wrong-key
;; upon reflection misspelling and wrong keys should have multiple options for correction
;; we probably should move ::correct-key to ::correct-keys
;; but the scores of the top choices should be close and in order 

(derive ::wrong-key ::unknown-key)

;; depends on previous error-upgrade failing
(eliminate-siblings ::wrong-key ::misspelled-key)

(defmethod upgrade-to-error-type? ::wrong-key [_ err]
  (when-let [suggest
             (and
              (::keys->specs err)
              (strict-impl/replacement-suggestion
               (parse/keys-specs->keys-args (::keys->specs err))
               (:val err)
               (::unknown-key err)))]
    (assoc err
           ::error-type ::wrong-key
           ::wrong-key (::unknown-key err)
           ::correct-key suggest)))

#_(upgrade-error (test-e
                  (strict-keys
                   :opt-un [:strictly-specking.test-schema/build-config])
                  {:forest {:id "asdf"
                            :source-paths ["src"]
                            :compiler {:output-to "main.js"}}}))

#_ (error-path (upgrade-error (test-e
                  (strict-keys
                   :opt-un [:strictly-specking.test-schema/build-config])
                  {:forest {:id "asdf"
                            :source-paths ["src"]
                            :compiler {:output-to "main.js"}}})))

(defmethod error-message ::wrong-key [{:keys [path pred val reason via in] :as e}]
  (str "The key " (color (pr-str (error-key (::error-path e))) :error-key)
       " is unrecognized. Perhaps you meant "
       (color (pr-str (::correct-key e)) :correct-key)
       "?"))

(defmethod inline-message ::wrong-key [e]
  (correct-key-message e))

(defmethod keys-to-document ::wrong-key [e]
  (correct-keys-to-document e))

(comment
  (let [data {:forest {:id "asdf"
                       :source-paths ["src"]
                       :compiler {:output-to "main.js"}}}
        errs (s/explain-data (strict-keys
                              :opt-un [:strictly-specking.test-schema/build-config])
                             data)]
    (dev-print errs
               data
               nil)
    (prepare-errors errs
                    data
                    nil)

    (keys-to-document (first (prepare-errors errs
                    data
                    nil)))

    )
  
  )



;; *** misplaced key
;; 

(derive ::misplaced-key ::unknown-key)

(eliminate-siblings ::misplaced-key ::misspelled-key ::wrong-key)

(defn misplaced-key-error? [err]
  ;; need the root
  ;; perhaps the first of :via??
  (when-let [ky (and (first (:via err)) (::unknown-key err))]
    (when-let [possible-paths
               (not-empty
                (path-match/filter-possbile-path-choices
                 err
                 (parse/find-key-path-without-ns (first (:via err)) ky)))]
      (let [[suggested-path-reified
             suggested-path] (path-match/best-possible-path possible-paths (::root-data err))]
        {::suggested-path suggested-path-reified
         ::document-keys [(-> suggested-path last :ky-spec)]}))))

(defmethod upgrade-to-error-type? ::misplaced-key [_ err]
  (when-let [merge-data (misplaced-key-error? err)]
    (-> err
        (merge merge-data)
        (assoc ::error-type ::misplaced-key))))

(comment

(def tttttest {:cljsbuild
                   {:builds
                    {:dev
                     {:compiler
                      {:figwheel
                       {:websocket-host "localhost"
                        :on-jsload      'example.core/fig-reload
                        :on-message     'example.core/on-message
                        :debug true}}}}}})

(upgrade-error (->> (s/explain-data :strictly-specking.test-schema/lein-project-with-cljsbuild
                                    tttttest)
                    ::s/problems
                    (filter ::unknown-key)
                    first
                    (merge {::root-data tttttest})))
  #_(error-path)

  #_(fix-error-path* (->> (s/explain-data :strictly-specking.test-schema/lein-project-with-cljsbuild
                                       tttttest)
                       ::s/problems
                       (filter ::unknown-key)
                       first
                       )
                   tttttest)
  
  (let [res (upgrade-error (->> (s/explain-data :strictly-specking.test-schema/lein-project-with-cljsbuild
                                                tttttest)
                                ::s/problems
                                (filter ::unknown-key)
                                first
                                (merge {::root-data tttttest})))]
    [(error-path res) res])

  
  
  )


(defmethod error-message ::misplaced-key [e]
  (str "The key " (color (pr-str (::unknown-key e)) :focus-key)
       " at " (color (pr-str (error-path-parent (::error-path e))) :focus-path)
       " is on the wrong path."))

(defmethod inline-message ::misplaced-key [e]
  (str "The key " (pr-str (-> e ::unknown-key)) " has been misplaced"))

;; TODO no need to look up the key here
(defmethod keys-to-document ::misplaced-key [e]
  (::document-keys e))


(comment
  (let [data {:cljsbuild
                   {:builds
                    {:dev
                     {:compiler
                      {:figwheel
                       {:websocket-host "localhost"
                        :on-jsload      'example.core/fig-reload
                        :on-message     'example.core/on-message
                        :source-map true
                        :debug true}}}}}}
        errs (s/explain-data :strictly-specking.test-schema/lein-project-with-cljsbuild
                             data)]
    (dev-print errs
               data
               nil)
    (prepare-errors errs
                    data
                    nil)


    )

  )





#_(parse/find-key-path-without-ns :cljsbuild.lein-project.require-builds/cljsbuild
                                  :figwheel)

#_(s/describe :strictly-specking.test-schema/builds)

#_ (upgrade-to-misplaced-error test-error2)

#_(defn upgrade-to-misplaced-errors [errors]
  (map #(if (= (::error-type %) ::unknown-key)
          (upgrade-to-misplaced-error %) %) errors))


#_(comment
    (test-e
     (strict-keys
      :opt-un [:strictly-specking.test-schema/build-config])
     {:forest {:id "asdf"
               :source-paths ["src"]
               :compiler {:output-to "main.js"}}})
    )





#_(comment
  (defn test-e [sp v]
    (-> (s/explain-data sp v) ::s/problems first
        (assoc ::root-data v))
    
    )
  
  #_(test-e (s/every integer? :min-count 2) [])
  )

#_(upgrade-error (test-e (s/every integer? :min-count 1) []))



;; so we will register new error types with derive

;; the root error will be the ::bad-value error



;; nothing to derive

;; this is just a registered predicate for a certain error-type to see if the
;; error is that type



;; this will walk the descendent chain










;; *** mark errors with a type

#_(defn error-type [error]
  (cond
    (error ::error-type)       (error ::error-type) 
    (error ::unknown-key)      ::unknown-key
    (error ::misspelled-key)   ::misspelled-key
    (error ::wrong-key)        ::wrong-key
    (error ::missing-keys)     ::missing-required-keys
    (and (= (:reason error) "Insufficient input")
         (= (:val error) '())) ::should-not-be-empty
    (= (:pred error) '(clojure.core/<= 1 (clojure.core/count %) Integer/MAX_VALUE))
    ::should-not-be-empty
    ;; add wrong size collection
    :else ::bad-value))

#_(defn add-error-type [error]
  (assoc error ::error-type (error-type error)))

;; *** fix map tuple keys
;; Since the every-kv breaks the :in path for maps
;; we have defined a map-of and a non-empty-map-of above
;; these have paths that we can fix

;; I really prefer not to mess with this but making the
;; :in path work when the path goes through a every-kv
;; seems non trivial.

;; If the :in path gets fixed we can detect if an error is a
;; key error by noting if the :val is = to the (comp last :in)

#_(defn map-tuple-path-element? [x]
  (and (vector? x)
       (= (first x)
          ::tuple-map-key)))

#_(defn map-tuple-path? [p]
  (some map-tuple-path-element? p))

#_(defn fix-map-path [p]
  (loop [p p
         res []]
    (if-let [f (first p)]
      (if (and (vector? f)
               (= (first f)
                  :strictly-specking.core/tuple-map-key))
        (if (#{0 1} (first (rest p))) ;; if this "bug" gets fixed this shouldn't break
          (recur (rest (rest p)) (conj res (second f)))
          (recur (rest p) (conj res (second f))))
        (recur (rest p)        (conj res f)))
      res)))

#_(fix-map-path [[:strictly-specking.core/tuple-map-key :ASdf]
                 1
                 [:strictly-specking.core/tuple-map-key :asdf]
                 1])


;; upgrade to bad keys

#_(defn upgrade-to-bad-key [e]
  (if (and (map-tuple-path-element? (last (butlast (:in e))))
           (= 0 (last (:in e))))    
    (assoc e ::error-type ::bad-key)
    e))

#_(defn fix-map-paths [errors]
  (map
   #(if (map-tuple-path? (:in %))
      (-> %
          upgrade-to-bad-key
          (update-in [:in] fix-map-path))
      %)
   errors))

#_(fix-map-paths ['{:path [0],
                    :pred keyword?,
                    :val 3,
                    :via [],
                    :in [[:strictly-specking.core/tuple-map-key 3] 0]}])

;; *** parse out and added missing keys data on error

#_(defn add-required-keys [error]
  (if-let [missing-required-keys (missing-keys error)]
    (assoc error ::missing-keys (missing-keys error))
    error))

;; *** apply initial data transforms on errors 

#_(defn filter-errors [problems]
  (->> problems
       #_(map (fn [[k v]] (assoc v :path k)))
       (map add-required-keys)
       (map add-error-type)))

;; *** combine errors for single location
;; Sometimes there are multiple errors on the same path location

(defn combined-or-pred [errors]
  (let [errors-to-comb
        (->> errors
             (filter #(= (::error-type %) ::bad-value))
             (group-by :in)
             (filter #(< 1 (count (second %))))
             (map (fn [[_ errors]]
                    (assoc (first errors)
                           :pred (cons 'or (map :pred errors))
                           :path (cons ::combined-path (map :path errors))
                           ::error-type ::bad-value-comb-pred))))
        paths (set (map :in errors-to-comb))]
    (concat (filter #(not (paths (:in %))) errors)
            errors-to-comb)))

(defn combined-or-key-pred [errors]
  (let [errors-to-comb
        (->> errors
             (filter #(= (::error-type %) ::bad-key))
             (group-by (comp :in-path ::error-path))
             (filter #(< 1 (count (second %))))
             (map (fn [[_ errors]]
                    (assoc (first errors)
                           :pred (cons 'or (map :pred errors))
                           :path (cons ::combined-path (map :path errors))
                           ::error-type ::bad-key-comb-pred))))
        paths (set (map (comp :in-path ::error-path) errors-to-comb))]
    (concat (filter #(not (paths (-> % ::error-path :in-path))) errors)
            errors-to-comb)))

;; *** combine missing-keys errors
;; missing keys for the same location can be combined

(defn combined-missing-keys [errors]
  (let [errors-to-comb
        (->> errors
             (filter #(= (::error-type %) ::missing-required-keys))
             (group-by :in)
             (filter #(< 1 (count (second %))))
             (map (fn [[_ errors]]
                    (assoc (first errors)
                           :pred (cons 'and (map :pred errors))
                           ::missing-keys (vec (mapcat ::missing-keys errors))))))
        paths (set (map :in errors-to-comb))]
    (concat (filter #(not (paths (:in %))) errors)
            errors-to-comb)))

;; *** corrections overide missing
;; if there is an error with a ::correct-key in it eliminate any ::missing-required-keys reference

(defn l [t x]
  (prn t x)
  x)

(defn corrections-overide-missing-required [errors]
  (if-let [corrected-key-errors (not-empty (filter ::correct-key errors))]
    (let [key-paths  (set (map (juxt ::correct-key :in)
                               corrected-key-errors))
          fixed-errs
          (->> errors
               (keep (fn [e]
                       (if-let [kps (and (::missing-keys e)
                                         (not-empty
                                          (set/intersection
                                           key-paths
                                           (set (map #(vector % (:in e)) (::missing-keys e))))))]
                         (when-let [keys-left  (not-empty (set/difference (set (::missing-keys e))
                                                                          (set (map first key-paths))))]
                                       (assoc e ::missing-keys (seq keys-left)))
                         e)))
               not-empty)]
      fixed-errs)
    errors))


;; *** upgrade :unknown-key to misplaced key



#_(defn upgrade-to-misplaced-error [err]
  ;; need the root
  ;; perhaps the first of :via??
  (if-let [ky (and (first (:via err)) (::unknown-key err))]
    (if-let [possible-paths
             (not-empty
              (filter-possbile-path-choices
               err
               (parse/find-key-path-without-ns (first (:via err)) ky)))]
      (let [[suggested-path-reified
             suggested-path] (best-possible-path possible-paths (::root-data err))]
        (assoc err
               ::suggested-path suggested-path-reified
               ::document-keys [(-> suggested-path last :ky-spec)]
               ::error-type ::misplaced-key))      
      err)
    err))

#_(parse/find-key-path-without-ns :cljsbuild.lein-project.require-builds/cljsbuild
                                  :figwheel)

#_(s/describe :strictly-specking.test-schema/builds)

#_ (upgrade-to-misplaced-error test-error2)

#_(defn upgrade-to-misplaced-errors [errors]
  (map #(if (= (::error-type %) ::unknown-key)
          (upgrade-to-misplaced-error %) %) errors))

;; *** TODO specific paths filter out general paths if something fails
;; at a deeper path it takes precedence over and filters out more
;; general paths this implies that the more general path succeeded in
;; a certain branch and that path is the one that is failing

(defn sub-path? [sub-path* path]
  (and (<= (count sub-path*) (count path))
       (reduce #(and %1 %2) true (map = path sub-path*))))

(defn specific-paths-filter-general [errors]
  (->> errors
       (sort-by (comp - count :in-path ::error-path))
       (reduce (fn [accum err]
                 (let [in-path (:in-path (::error-path err))]
                   (if (some #(sub-path? in-path %) (keys accum))
                     accum
                     (assoc accum in-path err)))) {})
       vals))

#_(specific-paths-filter-general [{::error-path {:in-path [1 2 3 ]}}
                                  {::error-path {:in-path [1 2 3 4]}} ])


#_(->> terrors
      ::s/problems
      filter-errors
      sort-errors
      combined-or-pred
      corrections-overide-missing-required
      #_(map error-message)
      #_(map println))

#_(filter-errors (::s/problems terrors))


;; ** sorting errors
;;  give types to errors
;;  sort them by importance

#_(def ^:dynamic *error-precedence*
  [::misspelled-key
   ::wrong-key
   ::missing-required-keys
   ::attach-reason
   ::unknown-key
   ::should-not-be-empty
   ::bad-key-comb-pred
   ::bad-key   
   ::bad-value-comb-pred
   ::bad-value])

(defn sort-errors [errors]
  (let [order (vec (reverse (total-order)))]
    (sort-by
     (fn [v] (let [pos (.indexOf order (::error-type v))]
               (if (neg? pos) 10000 pos))) errors)))

;; still rough
;; need a notion of a source ;; pure data vs. file source
(defn prepare-errors [explain-data validated-data file]
  (->> explain-data
       ::s/problems
       #_filter-errors
       (map #(assoc % ::root-data validated-data))
       (map #(if file (assoc % ::file-source file) %))
       (map upgrade-error)
       #_fix-map-paths
       
       #_upgrade-to-misplaced-errors
       sort-errors
       (map #(assoc % ::error-path (error-path %)))
       combined-missing-keys
       combined-or-pred
       combined-or-key-pred
       corrections-overide-missing-required
       specific-paths-filter-general))



#_ (map keys-to-document )









(defmulti update-display-data (comp ::error-type :error))

(defmethod update-display-data :default [disp-data] disp-data)

(defn generate-suggested-path-data [err suggested-path final-key]
  (let [[path vl] (if-let [parent-collection
                           (get-in (::root-data err)
                                   (butlast suggested-path))]
                    (if (map? parent-collection)
                      [(butlast suggested-path) (assoc parent-collection
                                                       final-key (:val err))]
                      [suggested-path (:val err)])
                    [suggested-path (:val err)])]
    (path-match/generate-path-structure (::root-data err) path vl)))

(defmethod update-display-data ::misplaced-key [disp-data]
  (let [err (:error disp-data)]
    (assoc disp-data
           :extra-explain (str "The " (::unknown-key err)
                               " key should probably be placed like so: ")
           :extra-diagram (with-out-str
                            (ep/pprint-sparse-path
                             (generate-suggested-path-data
                              err
                              (::suggested-path err)
                              (::unknown-key err))
                             #_(generate-path-structure
                              (::root-data err)
                              (::suggested-path err)
                              (:val err))
                             (butlast (::suggested-path err))
                             {(::unknown-key err)
                              (str "The key " (::unknown-key err)
                                   " should probably be placed in this map")}
                             {:key-colors [:good]})))))

;; TODO the raw line data may be more appropirate to ship over
;; the wire to a client
(defn error->display-data [error]
  (update-display-data
   {:error error
    :message (error-message error)
    :error-in-context (with-out-str (pprint-inline-message error))
    :path (:in error)
    :doc-keys (keys-to-document error)
    :docs (not-empty (fetch-docs (keys-to-document error)))}))

(defn test-print [error-data]
  (println (color "---------------------------------\n" :header))
  (println (:message error-data))
  (println "\n")
  ;; could should indent this
  (println (:error-in-context error-data))
  (println "\n")
  (when (:extra-explain error-data)
    (println (:extra-explain error-data))
    (println "\n"))
  (when (:extra-diagram error-data)
    (println (:extra-diagram error-data))
    (println "\n"))
  (when (:extra-extra-explain error-data)
    (println (:extra-extra-explain error-data))
    (println "\n"))
  #_(println "Docs " (prn (:doc-keys error-data)))
  (when (not-empty (:docs error-data))
    (doseq [[ky doc] (:docs error-data)]
      (println "-- Docs for key" (pr-str (keyword (name ky)))"--")
      (println doc)
      (println "\n")))
  (doseq [[k v] error-data
          :when (not (#{:message :error-in-context :extra-explain :extra-diagram
                        :extra-extra-explain :docs :final-notes
                        :path :error :doc-keys}
                      k))]
    (println "--" (pr-str k) "--")
    (println v)
    (println "\n"))
  (when (:final-notes error-data)
    (println (:final-notes error-data))
    (println "\n"))
  (println (color "---------------------------------\n" :footer)))

#_ (prepare-errors (s/explain-data :fig-opt/build-config {:id 1
                                                          :source-path [1 2]})
                   {}
                   "asdf")

(defn dev-print [explain-data data-to-test file-name]
  (with-ansi
    (->> 
     (prepare-errors explain-data data-to-test file-name)
     (map error->display-data)
     #_(take 1)
     (mapv test-print))))

(comment
  (def structer (read-string (slurp "tester.edn")))

  (def terr (s/explain-data :fig-opt/builds structer))

  #_(prepare-errors  terr structer "tester.edn")
  (dev-print terr structer nil #_"tester.edn")

  )


;; * thoughts
;; ** Data needs for spec failure error expression
;; *** top level needs
;; **** display the error in situ

;; its important the display the error in it the context of its
;; original data structure

;; this is more powerful if the data structure is a in source form
;; such as edn in a file

;; not having an edn structure we are only left with displaying it
;; in the context of pure data.

;; its also important to be able to display relevant documentation
;; for various keys involved in the error

;; This brings up the following needs:
;; ***** the original data structure
;; ***** the source be it file or some string
;; ***** the path to the error
;; this path needs to work function with the original data structure
;; ***** when the last element of the path is a key to a map
;; we need to know if it points to the value or the key itself

;; **** types of errors that can occur
;; ***** non conforming value error
;; the value at the path does not comply

;; A value error needs
;; - the path that ends at the key that points at the value
;; - the knowledge that the path points to the value
;; - what was wrong with the value - the specs that failed
;; - the data to look up the docs for that key

;; path to error value

;; this is a global need for all errors
;; - a message that clarifies the error given the above data

;; but in a way everything is a value error at some level
;; if there is a key pointing to a value that the error is in.

;; For example if a map has an unknown-key, the map in its
;; entirety could be the bad value for a parent key
;; the some errors can be made more specific by upgrading
;; them to a more specific error.

;; -----
;; there will be more specific bad value errors
;; ::should-not-be-empty
;; ::collection-wrong-size
;; these will be available for different concrete errors
;; that caused by built in macro predicates
;; -----

;; here are some upgraded errors
;; ***** missing required key error
;; a required key is missing from the map
;;
;; this is an upgrade of a bad value error on the parent
;; need to detect this error and upgrade


;; ****** TODO
;; error-path-type
;; { :in-path [] ;; a vector path that works with get-in on the root datastructure 
;;   :error-focus :value ;; or :key
;;   :missing-key true }
;; error-parent-path always butlast of :path
;; method error-path
;; method error-docs
;; method keys-to-document




;; 
;; methods
;; - context-print-path
;;   again path itself holds notion of pointing to the key or value
;; - bad-value-path
;;   path to bad value
;; - focus-keys
;;   the keys in the collection that have the focus

;; really this notion breaks down in many cases
;; can we have an error with several erroneous keys in a single erroneous value?
;; Then we will want a notion of a path to the parent collection
;; and a notion of a set of eronneous keys
;; OR instead of combining errors a notion of merging them into the same report
;; so that we can display them in the same structure
;; part of merging would be collision


;; notion of printing path

;; needs
;; - predicate to spot this bad value error
;; - upgrade this error path by appending the missing key
;; - an indicator that the key is the focus of the error
;; - document the key that is required
;;   this means we need the ns-key to look up documentation
;; - upgrade the data-structure visualizaion to display the missing key
;;  - in the case of an edn structure add some keys and values
;;  - in the case of a file source insert some lines with the missing key values
;;
;; the strange printing needs of this error point out a need for a in
;; context printing hook

;; ***** unknown-key
;; an unknown-key is present in a map
;;
;; this is an upgrade from a bad value error

;; - need to display list of correct keys
;; - need a predicate to detect this error type
;; - need to upgrade the path:
;;   - need a path to the key
;;   - need an indicator that this is a key error
;; - *no* documentation is needed perhaps documentation on the
;; parent key

;; in a certain mode this would just be awarning

;; ***** mispelled key error
;; a key has been determined to be a likely mispelling

;; this is an upgrade from an unkown-key error
;; it will use the corrected paths

;; we need a predicate to detect this error
;;   - this predicate needs the other possible keys in the map
;;   - it needs to know the keys in the map already
;;   - it needs to be able to validate the value against the
;;     alternate key suggestions
;;   - the :val and the map of keys->ns-key-specs can provide the
;;     bulk of these data needs
;;   - can possibly use the parent-spec to find these keys (last :via)

;; need to document the suggestion

;; should really consider displaying serveral suggestions

;; should consider that this could just be a warning in a certain mode
;; the warning would warn about unknown keys and provide the possible misspellings

;; ***** wrong key error

;; very similar to the mispelled key and is only tried if no mispelling is found
;; it just determines suggestions based on the shap of the unkown keys value
;; trying to find the best match in the

;; again its an evolution of an unknown-key
;; it will reuse the path information in it

;; we need a predicate to detect this error
;;   - this predicate needs the other possible keys in the map
;;   - it needs to know the keys in the map already
;;   - it needs to be able to validate the value against the
;;     alternate key suggestions
;;   - the :val and the map of keys->ns-key-specs can provide the
;;     bulk of these data needs
;;   - can possibly use the parent-spec to find these keys (last :via)

;; this predicate would return an error modified with the correct information
;;    the name of the correct-key (we already know the focus-key)

;; need to document the suggestion(s)
;; 

;; ***** misplaced key
;; this is an error that occurs when the key likey belongs somewhere
;; else in the datastructure

;; this is an upgrade of an unknown-key

;; this is only tried if a local mispelling error and a local wrong key error
;; hasn't been detected

;; need a predicate to detect this error
;; this predicate needs to do enough computation that it's probably better to dual purpose
;; this predicate such that it returns a modified error with added information
;;   
;;

;; ***** mispelled misplaced key


;; ***** global wrong key
;; the key has a wrong value but the value has sufficietn complexity
;; and validates correrctly against another position


;; ***** wrong placement of structure
;; key has wrong value but the value has sufficient complexity
;; and belongs somewhere else

;; need to be able to turn up and down the level of validation errors
;; just listing the errors might not work because there are evolutions
;; of errors



;; **** Notes
;; looks like we may just be able to have an indicator of a :focus-shift
;; that points one more level deep in the associative structure
;; and indicates if its a key problem "or a value problem" (TODO it might never
;; be a valure problem)



;; pprint is in annotated-pprint.clj

;; create an extra error message addendum

;; contextual printing is in print-context.clj

;; create some functionality to add code context to errors if the
;;   source-file(s) is known sjacket can be useful here

;; printing errors
;;   create a intermediate data structure - this will be useful for exception data
;;     :error with the original error
;;     :description a more meaningful description of whats gone wrong with an error message function
;;     :error-on is this on :value or :key
;;     :path to error key
;;     :path-str  path printing -- explore using pprint to get rid of a dependency
;;     :code-context -- error displayed along with code
;;     :alternate-path
;;     :alternate-path-str
;;     :doc   docs
;;  create a printer that outputs formatted error

;; key based error message
;;   hang a method off of an ns/keyword
;;   it takes an error, the complete data structure, a path to the key
;;   and it will provide a better error message than the stock one

;; docs on keys
;;   create a macro that stores docs on namespaced keys
;;   this can should be added to metadata in the registry on strictly-specking/docs etc

;; deeper error explain
;;   hang a method off of a keyword
;;   it takes an error, the complete data structure, a path to the key
;;   and gives a more detailed explaination of why that value is the wrong value
;;   this will hook into the main message error printing

;; explain
;;   create a macro that stores a method on a ns/key
;;   that given all the config data, and a path to the key
;;   that will provide an explanation of the behavior of that key
;;   in its current value, in conjuntion with the rest of the configuration


(defn init-test-rules []
  (s/def :fig-opt/housers1 string?)
  (s/def :fig-opt/housers2 string?)
  (s/def :fig-opt/housers3 string?)
  
  (s/def :fig-opt/house (strict-keys
                         :opt-un [:fig-opt/housers1 
                                  :fig-opt/housers2 
                                  :fig-opt/housers3
                                  :fig-opt/car1]))
  
  (s/def :fig-opt/car1 string?)
  (s/def :fig-opt/car2 string?)
  (s/def :fig-opt/car3 string?)
  
  (s/def :fig-opt/car (strict-keys
                       :opt-un [:fig-opt/car1
                                :fig-opt/car2
                                :fig-opt/car3]))
  
  (s/def :fig-opt/real (strict-keys
                        :opt-un [:fig-opt/car
                                 :fig-opt/house]))
  
  (s/def :build-config/id (s/or :string string? :keyword keyword?))
  (s/def :build-config/source-paths (s/+ string?))
  (s/def :build-config/asdfasdf (s/* string?))  
  (s/def :build-config/assert #(or (true? %) (false? %)))
  (s/def :fig-opt/build-config (strict-keys :req-un [
                                                     :build-config/id
                                                     :build-config/source-paths]
                                            :opt-un [:build-config/assert
                                                     :build-config/asdfasdf]))

  (s/def :fig-opt/loose-build-config (s/keys :req-un [
                                                      :build-config/id
                                                      :build-config/source-paths]
                                             :opt-un [:build-config/assert
                                                      :build-config/asdfasdf]))
  
  
  (s/def :fig-opt/http-server-root string?)
  (s/def :fig-opt/server-port      integer?)
  (s/def :fig-opt/server-ip        string?)
  (s/def :fig-opt/builds           (s/+ :fig-opt/build-config))
  
  
  (s/def :project-top/figwheel (strict-keys
                                :opt-un [:fig-opt/http-server-root
                                         :fig-opt/server-port
                                         :fig-opt/server-ip]
                                :req-un [:fig-opt/builds]))
  
  
  )

#_(init-test-rules)



